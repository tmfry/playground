# shellcheck shell=bash
set +x
set -e

# --- Core Tools Check ---
# Ensure essential tools are available
strict_env has make
strict_env has pyenv


# --- Data & Secrets Loading ---
# Load secrets from a local .env file if it exists.
if [[ -f .env ]]; then
    dotenv .env
fi

LOCAL_ENVRC_LOCAL=".envrc.local"
# Load very specific local overrides that don't sync across user machines
source_env_if_exists "${LOCAL_ENVRC_LOCAL}"

# --- Project Utilities ---
# Add local 'bin' directory to PATH if it exists.
if [[ -d "${PWD}/bin" ]]; then
    PATH_add ./bin
fi


# --- Security: GitIgnore Checks & Symlink Management ---
LOCAL_DIR=".local"
LOCAL_ENVRC=".envrc"
LOCAL_GITIGNORE=".gitignore"
DEV_CORE_DIR_NAME=".dev_core"
# Default to WHITE LIST mode (1), unless explicitly set otherwise in .env or shell
export GITIGNORE_WHITE_LIST="${GITIGNORE_WHITE_LIST:-1}"
# Set GITIGNORE_WHITE_LIST=1 in .env for white-list mode, 0 for black-list.
if [[ "${GITIGNORE_WHITE_LIST}" == "1" ]] || [[ "${GITIGNORE_WHITE_LIST}" == "true" ]]; then
    # WHITE LIST Mode: Check if critical files are accidentally INCLUDED (FATAL ERROR if true).
    if grep -q "^!${LOCAL_ENVRC_LOCAL}" "${LOCAL_GITIGNORE}"; then
        echo "[DEV_CORE] FATAL ERROR: '${LOCAL_ENVRC_LOCAL}' is explicitly included in .gitignore." >&2
        exit 1
    fi
    if grep -q "^!${LOCAL_DIR}" "${LOCAL_GITIGNORE}"; then
        echo "[DEV_CORE] FATAL ERROR: '${LOCAL_DIR}/' is explicitly included in .gitignore." >&2
        exit 1
    fi
else
    # BLACK LIST Mode: Check if critical files are excluded (auto-append if missing).
    if ! grep -q "^${LOCAL_ENVRC_LOCAL}" "${LOCAL_GITIGNORE}"; then
        echo "[DEV_CORE] WARNING: Adding '${LOCAL_ENVRC_LOCAL}' to .gitignore." >&2
        echo "${LOCAL_ENVRC_LOCAL}" >> "${LOCAL_GITIGNORE}"
    fi
    if ! grep -q "^${LOCAL_DIR}" "${LOCAL_GITIGNORE}"; then
        echo "[DEV_CORE] WARNING: Adding '${LOCAL_DIR}' to .gitignore." >&2
        echo "${LOCAL_DIR}/" >> "${LOCAL_GITIGNORE}"
    fi
fi

# Reload .envrc automatically if .gitignore changes.
watch_file "${LOCAL_GITIGNORE}"

# Set secure permissions for local config files (assuming they exist locally).
chmod 700 "${LOCAL_ENVRC}"
chmod 700 "${LOCAL_ENVRC_LOCAL}"


# --- DEV_CORE Symlink Management & Sourcing ---
# The DEV_CORE_ROOT_PATH should ideally be in your global ~/.bashrc or .env.
DEV_CORE_ROOT_PATH="${DEV_CORE_ROOT_PATH:-$HOME/repos/.dev_core}"
LOCAL_CORE_PATH="${LOCAL_DIR}/${DEV_CORE_DIR_NAME}"

if [[ ! -d "${LOCAL_CORE_PATH}" ]] && [[ ! -L "${LOCAL_CORE_PATH}" ]]; then
    if [[ -d "${DEV_CORE_ROOT_PATH}" ]]; then
        echo "[DEV_CORE] Creating symlink to central configuration repository..."
        mkdir -p "${LOCAL_DIR}"
        ln -s "${DEV_CORE_ROOT_PATH}" "${LOCAL_CORE_PATH}"
        echo "[DEV_CORE] Symlink created."
    else
        echo "[DEV_CORE] ERROR: Central repository not found at ${DEV_CORE_ROOT_PATH}." >&2
        exit 1
    fi
fi
# Source the core configuration .envrc from the symlinked repo
source_env_if_exists "${LOCAL_CORE_PATH}/.envrc"


# --- PTH manager configuration & execution ---
# Configure and execute the PTH manager script.
# Set default values if not already defined in .env
export SHOULD_INJECT_PTH_FILE="${SHOULD_INJECT_PTH_FILE:-1}"
export PTH_MANAGER_ROOT="${PTH_MANAGER_ROOT:-$PWD}"
export DEV_SITE_PACKAGES_DIR="${DEV_SITE_PACKAGES_DIR:-$HOME/.pyenv/versions/playground/lib/python3.13/site-packages}"
export PTH_FILE_NAME="${PTH_FILE_NAME:-playground.pth}"
# Security Check: Ensure the target directory for PTH file injection exists
if [[ ! -d "${DEV_SITE_PACKAGES_DIR}" ]]; then
    echo "[PTH Manager] ERROR: Target Python site-packages directory not found at ${DEV_SITE_PACKAGES_DIR}." >&2
    echo "[PTH Manager] ACTION: Please check DEV_SITE_PACKAGES_DIR variable in your .env file." >&2
    exit 1
fi
# Load (source) the manager script into the current environment
PTH_MANAGER_SCRIPT_PATH="${HOME}/bin/pth_manager.sh"
# Execute the manager logic
# shellcheck disable=SC1090
if [[ -f "${PTH_MANAGER_SCRIPT_PATH}" ]]; then
    source "${PTH_MANAGER_SCRIPT_PATH}"
    if has "please_manage_pth"; then
        please_manage_pth
    else
        echo "[PTH Manager] WARNING: pth_manager.sh sourced, but please_manage_pth function not found." >&2
    fi
else
    echo "[PTH Manager] WARNING: pth_manager.sh script not found at ${PTH_MANAGER_SCRIPT_PATH}." >&2
fi


# --- Environment/Tool Path Additions ---
# Flag to enable/disable adding extra tool paths to the environment.
# Set in .env or via shell: export ENABLE_TOOL_PATHS=0 (to disable)
export ENABLE_TOOL_PATHS="${ENABLE_TOOL_PATHS:-0}"
if [[ "${ENABLE_TOOL_PATHS}" == "1" ]] || [[ "${ENABLE_TOOL_PATHS}" == "true" ]]; then
    PATH_add "${HOME}/.pyenv/versions/lint/bin/"
    PATH_add "${HOME}/.pyenv/versions/spell/bin/"
    PATH_add "${HOME}/.pyenv/versions/typing/bin/"
    PATH_add "${HOME}/.pyenv/versions/typos/bin/"
    PATH_add "${HOME}/.pyenv/versions/sec/bin/"
    echo "[EVNS] Info: Extra tool paths have been enabled."
fi


# --- Final Status Echo ---
printf "\e[1;33m"; python3 -V; printf "\e[0m\n"
